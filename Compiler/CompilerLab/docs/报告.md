# 编译原理实验报告

By 161250010 陈俊达

# 1. 目标

实现一个**能解析正则表达式和一些扩展语法的通用词法分析器**，和**使用LALR(1)进行语法分析的语法分析器**，并定义一个能够以上提到的分析器所解析的词法定义文件（`.myl`）和语法定义文件（`.myy`）的格式，并能够做到通过在系统指定的可用Token集合上，从用户给定的**词法定义文件**和**语法定义文件**，实现从**输入文件**到**产生式规约序列**的全过程。

# 2. 内容描述

本实验提供了以下内容：

- 一个Intellij IDEA格式的Java项目，包含了目标中提到的**词法分析器**、**语法分析器**以及对应分析器的一些测例。

- 能被分析器所解析的词法定义文件（`.myl`）和语法定义文件（`.myy`）的格式描述

- 以龙书上例题4.31为依据的输入文件、输出文件、myl词法定义文件和myy语法定义文件，并提供了对应的测例

- 一个C语言子集的输入文件、输出文件、myl词法定义文件和myy语法定义文件。同时还提供了与其中myl和myy等价的flex/bison定义文件以及对应的一些工具程序。提供的词法定义和语法定义已经经过flex和bison测试可以完整无错误的解析提供的输入文件。

# 3. 运行方法

## 3.1 初始化编程环境

1. 使用Jetbrains Intellij IDEA打开项目文件夹
2. 等待gradle下载依赖（本项目依赖[lombok](https://projectlombok.org/)和[junit](https://junit.org/junit4/)，使用gradle进行依赖管理）
3. 安装lombok的IDEA插件
4. 在IDEA Settings -> Build, Execution, Deployment -> Compiler -> Annotation Processors，对整个项目在右边勾选Enable Annotation Processing

## 3.2 运行以龙书例题4.31为依据的集成测试

要运行这个测试，请运行`test/java/IntegrationTest::testExample431`。这个测例将读取`main/java/resources/example4.31`下预先提供的输入文件、词法定义文件和语法分析文件，将输入文件进行词法和语法分析，得到规约序列，并与测试中写好的预期序列进行比较，得出测试结果。

## 3.3 一个C语言子集的运行示例

这个C语言子集提供了flex/bison项目以及基于等价myl, myy定义文件的运行方式。

这个C语言子集由于过于复杂，故没有提供示例输出文件。

flex/bison项目中包含了这个C语言子集对应的.l和.y定义文件。要运行flex/bison项目，请参考`CSubsetFlexBison`目录下的说明文档。

与flex/bison项目中提到的C语言子集等价的词法定义文件和语法定义文件，以及和flex/bison项目中示例文件test.c完全相同的示例输入文件均位于`main/java/resources/bigtest`下。测试用例`test/java/IntegrationTest::bigTest`将读取输入文件、词法定义文件和语法分析文件，将输入文件进行词法和语法分析，**输出**规约序列。注意此“测试”由于比较复杂（规约序列中包含200余条产生式），故只提供了程序的输出信息(`output`文件)，并没有进行正确性验证。

## 3.4 单元测试

在开发过程中，单元测试起到了测试一个功能点正确性的作用。本项目中`test/java/LexTest`和`test/java/SyntaxTest`包含了编写词法和语法分析器过程中所用到的单元测试，若有兴趣，可自行运行。

# 4. 假设


# 5. 重要数据结构的描述

## 5.1 词法分析器

词法分析器设计到的数据结构有DFA, DFANode, NFA, NFANode, Regex和RegexNode。

### 5.1.1 Regex和RegexNode

Regex顾名思义代表一个正则表达式，一个Regex是由一个RegexNode的列表所组成的。

一个RegexNode代表一个**正则表达式的符号**，其中**正则表达式的符号**即为正则表达式标准定义中的集几种组成元素，包括以下几种类型：

- 普通字符（包括escaped字符）
- 闭包（*）
- 并集（|）
- 连接（·）
- （转换到中缀表达式后消失）覆盖优先级（(, )）

每个RegexNode都存储了这个**RegexNode的类型**和**它的字面量值**，以及**其对应的优先级**。优先级仅用于连接和并集的优先级选择上，其中连接的连接的优先级高于闭包。这个优先级将会在**正则表达式中缀转后缀**的过程中起作用。

### 5.1.2 NFA和NFANode

NFA顾名思义代表一个对于一个**正则表达式**的NFA。本系统里的NFA是根据Thompson算法做出来的，而通过Thompson算法做出的**对于一个正则表达式的NFA只有一个结束状态**，故本系统中一个NFA是由代表开始状态的NFANode和一个代表结束状态的NFANode组成的。

NFANode代表一个NFA中的节点，或者说一个NFA的状态。一个NFANode是由一个**以自己为出发边的边的集合**和**对应的正则表达式所对应的token类型**所组成的。

前者（以自己为出发边的边的集合）在Java中的表示形式为`Map<Character, List<NFANode>>`，其key代表边上的字符，value代表通过key字符能够达到的状态的集合。

后者（对应的正则表达式所对应的token类型）对应**在词法定义文件中，满足此正则表达式的字符串应该被语法分析及其后续过程认为的Token的类型**。

### 5.1.3 DFA和DFANode

DFA顾名思义代表一个对于一份**词法定义文件**的DFA，由一个标志开始状态的DFANode和这个DFA所有的接受状态的列表组成。本系统里DFA是以下算法得到的：

1. 分析**词法定义文件**中所有的正则表达式，得到NFA
2. 新增一个开始状态，将这个开始状态和所有NFA的开始状态通过epsilon边相连接
3. 使用**子集构造算法**得到DFA。

DFANode代表一个DFA中的节点，或者说一个DFA的状态。一个DFANode是由**它所对应的NFA状态的集合**、**以自己的为出发边的边的集合**和**自己所对应的所有可能的token类型的集合**所组成的。

第一项（所对应的NFA状态的集合）即在子集构造算法中，构成这个DFA状态的NFANode的集合。

第二项（以自己的为出发边的边的集合）在Java中的表示形式为`Map<Character, List<NFANode>>`，其key代表边上的字符，value代表通过key字符能够达到的状态的集合。

第三项（自己所对应的所有可能的token类型的集合）即这个DFA状态对应的NFANode所**对应的正则表达式所对应的token类型**的交集。“这个DFA所对应的NFA状态的集合中包括至少一个结束状态的NFANode”是“DFANode所对应的所有可能的token类型的集合非空”的充要条件。通过保存这个集合能够减少词法分析的时间。








