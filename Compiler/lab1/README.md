## Lab1: Lexical Analyzer

Target: generate a lexical analyzer that can analyze ANSI C program with `flex`

Input: C Program

Output: sequence of tokens

References:

[GNU C Manual](https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.pdf)

[Detailed tutorial from Arizona University](https://www2.cs.arizona.edu/classes/cs453/fall14/DOCS/tutorial-large.pdf)

[ANSI C Lex Specification](https://www.lysator.liu.se/c/ANSI-C-grammar-l.html)

[Better ANSI C Lex Specification](http://www.quut.com/c/ANSI-C-grammar-l-2011.html#comment)

[Get started](http://www.cnblogs.com/itech/archive/2012/03/04/2375746.html)

[Lex regex definitions](http://www.csd.uwo.ca/~moreno/CS447/Lectures/Lexical.html/node11.html)

Notes:

1. Install `winflexbison3` with `chocolatey` and `gcc` with Mingw and make sure `win_flex` and `gcc` can be accessed from path.
2. Write a lex named `test.l`
3. Run `compile.ps1` to compile the lex file into an executable `test.exe`
4. Run `./test.exe` to start the parsing!

Predefined scripts:

`compile.ps1` parses `test.l` to `lex.yy.c` using `win_flex` and then compiles `lex.yy.c` to `test.exe` using `gcc`

`run.ps1` always runs `compile.ps1` first. `test.exe` will be executed if no arg is provided. If an arg is provided, it will be intepreted as a **filename**. The file would be read and the content will be piped into `test.exe`.
   
Pitfalls:

1. On Windows, since no lex libraries are installed with `winflexbison3`, to compile the `lex.yy.c` generated by flex, the following code snippet must be appended into the third part of the lex file (to provide a definition of yywrap and main function)

```c
int yywrap() 
{ 
   return(1); 
} 

int main()
{
    yylex();
}
```

2. Use a definition

Declare WS in the definitions part of the lex like this

```lex
WS [ \n\t]
```

and use it in the rule part like this

```lex
WS {\* ignored *\}
```

or 

It doesn't work as expected. The whitespaces are not picked by this definition and ignored.

```
auto break
<Keyword, "auto"><Unknown, " "><Keyword, "break">
```

Fix:

A definition should be used in rules part with a bracket wrapping the symbol. So it should be used like

```lex
{WS} {\* ignored *\}
```

Now it's working just fine

```
auto break
<Keyword, "auto"><Keyword, "break">
```

3. impossible non-greedy policy

This problem is first found trying to disallow 8, 9 in a octa number.

Define rules as follows:

```lex
0[0-7]+ { onmatch(INT_CONST); }
[1-9][0-9]* { onmatch(INT_CONST); }
```

Parse 01292 will result in

```
01292
<Integer Constant, "012">
<Integer Constant, "92">
```

However, it should output error.

Flex has a "longest leftmost match" policy(greedy) and [does not have a non-greedy operator](http://westes.github.io/flex/manual/Why-doesn_0027t-flex-have-non_002dgreedy-operators-like-perl-does_003f.html). Therefore flex would immediately match the token as long as it matches the regex and doesn't care about the following chars.

It may indicate that non-greedy policy is not possible during lexical analysis, and this kind of error should be found during syntax analysis.

4. String literal

String literal is big trouble because of its complicated rule. From my understanding a string literal can have following properties:

- Can contains any char(including escaped ones) and whitespaces(excluding \n) but single quote(') can be used without \ (aka "'" is valid)
- Can concatenate adjucant string connected with any (including no) whitespaces
- Can be break up into multiple lines connected with double quote(") or backslash (\\)

I write the following lex:

```lex
(\"((\\\n)|\'|({char})|[ \t])*\"({WS})*)+
```

which results in a no-op for any candidate string literal including simple ones like "asd".

First, I simplified it into this

```lex
(\"((\\\n)|\'|({char})|[ \t])*\")+

```

which gives correct result for simple strings like "123" and adjacent (no whitespace in between) strings like "123""123". So I believe there must be something to do with `({WS})*`

Adding only space([ ]) made it work fine and I suddenly realized that it has nothing to do with regex itself but how the input is handled internally: I input my string and pushed "Enter" button, which inserts a \n into in stream and pushes the buffer to the program to be executed. However, `({WS})*` would eat up the \n and the program would think that my input had not ended. So I will never get a response by this way. To prove this, I created a new file with "123"\n"123" inside and pipe it into the program, and then it works just fine.

```
<String Constant, "123"
"123"
>
```

Also I try this file in my program and it works just as expected:

input:
```
"123 \
123"
"123"
```

output:
```
<String Constant, "123 \
123"
"123"
>
```